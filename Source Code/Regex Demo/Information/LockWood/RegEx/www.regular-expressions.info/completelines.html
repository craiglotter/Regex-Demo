<HTML>
<!-- Mirrored from www.regular-expressions.info/completelines.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Examples: Matching Whole Lines of Text That Satisfy Certain Requirements</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Regular expression examples showing how you can match an entire line of text in a file, taking into account certain conditions as to what the line must or must not contain">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<H1>Matching Whole Lines of Text</H1> <P>Often, you want to match complete lines in a text file rather than just the part of the line that satisfies a certain requirement. This is useful if you want to delete entire lines in a search-and-replace in a <A HREF="editpadpro.html" TARGET="_top">text editor</A>, or collect entire lines in an <A HREF="powergrep.html" TARGET="_top">information retrieval tool</A>.</P> <P>To keep this example simple, let's say we want to match lines containing the word "John". The regex <TT CLASS=regex>John</TT> makes it easy enough to locate those lines. But the software will only indicate <TT CLASS=match>John</TT> as the match, not the entire line containing the word.</P> <P>The solution is fairly simple. To specify that we need an entire line, we will use the <A HREF="anchors.html" TARGET="_top">caret and dollar sign</A> and turn on the option to make them match at embedded newlines. In software aimed at working with text files like <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> and <A HREF="powergrep.html" TARGET="_top">PowerGREP</A>, the anchors always match at embedded newlines. To match the parts of the line before and after the match of our original regular expression <TT CLASS=regex>John</TT>, we simply use the <A HREF="dot.html" TARGET="_top">dot</A> and the <A HREF="repeat.html" TARGET="_top">star</A>. Be sure to turn <I>off</I> the option for the dot to match newlines.</P> <P>The resulting regex is: <TT CLASS=regex>^.*John.*$</TT>. You can use the same method to expand the match of any regular expression to an entire line, or a block of complete lines. In some cases, such as when using <A HREF="alternation.html" TARGET="_top">alternation</A>, you will need to group the original regex together using <A HREF="brackets.html" TARGET="_top">round brackets</A>.</P> <H2>Finding Lines Containing or Not Containing Certain Words</H2> <P>If a line can meet any out of series of requirements, simply use <A HREF="alternation.html" TARGET="_top">alternation</A> in the regular expression. <TT CLASS=regex>^.*\b(one|two|three)\b.*$</TT> <A HREF="regexbuddy/completelinesone.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A> matches a complete line of text that contains any of the <A HREF="wordboundaries.html" TARGET="_top">words</A> "one", "two" or "three". The first <A HREF="brackets.html" TARGET="_top">backreference</A> will contain the word the line actually contains. If it contains more than one of the words, then the last (rightmost) word will be captured into the first backreference. This is because the star is <A HREF="repeat.html" TARGET="_top">greedy</A>. If we make the first star lazy, like in <TT CLASS=regex>^.*?\b(one|two|three)\b.*$</TT>, then the backreference will contain the first (leftmost) word.</P> <P>If a line must satisfy all of multiple requirements, we need to use <A HREF="lookaround.html" TARGET="_top">lookahead</A>. <TT CLASS=regex>^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$</TT> <A HREF="regexbuddy/completelinesall.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A> matches a complete line of text that contains <I>all</I> of the <A HREF="wordboundaries.html" TARGET="_top">words</A> "one", "two" and "three". Again, the <A HREF="anchors.html" TARGET="_top">anchors</A> must match at the start and end of a line and the <A HREF="dot.html" TARGET="_top">dot</A> must not match line breaks. Because of the <A HREF="anchors.html" TARGET="_top">caret</A>, and the fact that lookahead is zero-width, all of the three lookaheads are attempted at the start of the each line. Each lookahead will match any piece of text on a single line (<TT CLASS=regex>.*?</TT>) followed by one of the words. All three must match successfully for the entire regex to match. Note that instead of words like <TT CLASS=regex>\bword\b</TT>, you can put any regular expression, no matter how complex, inside the lookahead. Finally, <TT CLASS=regex>.*$</TT> causes the regex to actually match the line, after the lookaheads have determined it meets the requirements.</P> <P>If your condition is that a line should <EM>not</EM> contain something, use negative lookahead. <TT CLASS=regex>^((?!regexp).)*$</TT> <A HREF="regexbuddy/completelinesnot.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A> matches a complete line that does <I>not</I> match <TT CLASS=regex>regexp</TT>. Notice that unlike before, when using positive lookahead, I repeated both the negative lookahead and the dot together. For the positive lookahead, we only need to find one location where it can match. But the negative lookahead must be tested at each and every character position in the line. We must test that <TT CLASS=regex>regexp</TT> fails everywhere, not just somewhere.</P> <P>Finally, you can combine multiple positive and negative requirements as follows: <TT CLASS=regex>^(?=.*?\bmust-have\b)(?=.*?\bmandatory\b)((?!avoid|illegal).)*$</TT> <A HREF="regexbuddy/completelinesmultiple.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>. When checking multiple positive requirements, the <TT CLASS=regex>.*</TT> at the end of the regular expression full of zero-width assertions made sure that we actually matched something. Since the negative requirement must match the entire line, it is easy to replace the <TT CLASS=regex>.*</TT> with the negative test.</P> <DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="completelines.html" TARGET="_top">http://www.Regular-Expressions.info/completelines.html</A><BR> Last Updated: 22 September 2004<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Examples</TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="floatingpoint.html" TARGET=_top>Floating&nbsp;Point&nbsp;Numbers</A></TD></TR><TR><TD><A HREF="dates.html" TARGET=_top>Valid&nbsp;Dates</A></TD></TR><TR><TD><A HREF="completelines.html" TARGET=_top>Matching&nbsp;Complete&nbsp;Lines</A></TD></TR><TR><TD><A HREF="duplicatelines.html" TARGET=_top>Deleting&nbsp;Duplicate&nbsp;Lines</A></TD></TR><TR><TD><A HREF="examplesprogrammer.html" TARGET=_top>Programming</A></TD></TR><TR><TD><A HREF="near.html" TARGET=_top></A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE><P>&nbsp;</P> <TABLE CLASS=side CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 3</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files, such as source code, correspondence, server or system logs, reference texts, archives, etc. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files, or thousands of files and folders.</TD></TR> <TR><TD CLASS=ad>Perform comprehensive text and binary replacement operations for easy maintenance of web sites, source code, reports, etc. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Work with plain text files, Unicode files, binary files, files stored in zip archives, and even MS Word documents, Excel spreadsheets and PDF files. Runs on Windows 98, ME, NT4, 2000 &amp; XP.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/completelines.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
</HTML>
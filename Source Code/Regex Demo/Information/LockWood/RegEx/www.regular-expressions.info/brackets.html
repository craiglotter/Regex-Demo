<HTML>
<!-- Mirrored from www.regular-expressions.info/brackets.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - Round Brackets for Grouping and Backreferences</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In a regular expression, round brackets can be used to group regex tokens together and for creating backreferences.  Backreferences allow you to reuse part of the regex match in the regex, or in the replacement text.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Use Round Brackets for Grouping</H1> <P>By placing part of a regular expression inside round brackets or parentheses, you can group that part of the regular expression together. This allows you to apply a regex operator, e.g. a <A HREF="repeat.html" TARGET="_top">repetition operator</A>, to the entire group. I have already used round brackets for this purpose in previous topics throughout this tutorial.</P> <P>Note that only round brackets can be used for grouping. Square brackets define a <A HREF="charclass.html" TARGET="_top">character class</A>, and curly braces are used by a <A HREF="repeat.html#limit">special repetition operator</A>.</P> <H2>Round Brackets Create a Backreference</H2> <P>Besides grouping part of a regular expression together, round brackets also create a "backreference". A backreference stores the part of the string matched by the part of the regular expression inside the parentheses.</P> <P>That is, unless you use non-capturing parentheses. Remembering part of the regex match in a backreference, slows down the regex engine because it has more work to do. If you do not use the backreference, you can speed things up by using non-capturing parentheses, at the expense of making your regular expression slightly harder to read.</P> <P>The regex <TT CLASS=regex>Set(Value)?</TT> matches <TT CLASS=match>Set</TT> or <TT CLASS=match>SetValue</TT>. In the first case, the first backreference will be empty, because it did not match anything. In the second case, the first backreference will contain <TT CLASS=match>Value</TT>.</P> <P>If you do not use the backreference, you can optimize this regular expression into <TT CLASS=regex>Set(?:Value)?</TT>. The question mark and the colon after the opening round bracket are the special syntax that you can use to tell the regex engine that this pair of brackets should not create a backreference. Note the question mark after the opening bracket is unrelated to the question mark at the end of the regex. That question mark is the regex operator that makes the previous token <A HREF="optional.html" TARGET="_top">optional</A>. This operator cannot appear after an opening round bracket, because an opening bracket by itself is not a valid regex token. Therefore, there is no confusion between the question mark as an operator to make a token optional, and the question mark as a character to change the properties of a pair of round brackets. The colon indicates that the change we want to make is to turn off capturing the backreference.</P> <H2>How to Use Backreferences</H2> <P>Backreferences allow you to reuse part of the regex match. You can reuse it inside the regular expression (see below), or afterwards. What you can do with it afterwards, depends on the tool you are using. In <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> or <A HREF="powergrep.html" TARGET="_top">PowerGREP</A>, you can use the backreference in the replacement text during a search-and-replace operation by typing <TT>\1</TT> (backslash one) into the replacement text. If you searched for <TT CLASS=regex>EditPad (Lite|Pro)</TT> and use <TT CLASS=string>\1 version</TT> as the replacement, the actual replacement will be <TT CLASS=string>Lite version</TT> in case <TT CLASS=match>EditPad Lite</TT> was matched, and <TT CLASS=string>Pro version</TT> in case <TT CLASS=match>EditPad Pro</TT> was matched.</P> <P>EditPad Pro and PowerGREP have a unique feature that allows you to change the case of the backreference. <TT>\U1</TT> inserts the first backreference in uppercase, <TT>\L1</TT> in lowercase and <TT>\F1</TT> with the first character in uppercase and the remainder in lowercase. Finally, <TT>\I1</TT> inserts it with the first letter of each word capitalized, and the other letters in lowercase.</P> <P>Regex libraries in programming languages also provide access to the backreference. In Perl, you can use the magic variables <TT>$1</TT>, <TT>$2</TT>, etc. to access the part of the string matched by the backreference. In <A HREF="dotnet.html" TARGET="_top">.NET (dot net)</A>, you can use the <TT>Match</TT> object that is returned by the <TT>Match</TT> method of the <TT>Regex</TT> class. This object has a property called <TT>Groups</TT>, which is a collection of Group objects. To get the string matched by the third backreference in C#, you can use <TT>MyMatch.Groups[3].Value</TT>.</P> <P><A HREF="dotnet.html" TARGET="_top">The .NET (dot net) Regex class</A> also has a method <TT>Replace</TT> that can do a regex-based search-and-replace on a string. In the replacement text, you can use <TT>$1</TT>, <TT>$2</TT>, etc. to insert backreferences.</P> <P>To figure out the number of a particular backreference, scan the regular expression from left to right and count the opening round brackets. The first bracket starts backreference number one, the second number two, etc. Non-capturing parentheses are not counted. This fact means that non-capturing parentheses have another benefit: you can insert them into a regular expression without changing the numbers assigned to the backreferences. This can be very useful when modifying a complex regular expression.</P> <H2>The Entire Regex Match As Backreference Zero</H2> <P>Certain tools make the entire regex match available as backreference zero. In <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> or <A HREF="powergrep.html" TARGET="_top">PowerGREP</A>, you can use the entire regex match in the replacement text during a search and replace operation by typing <TT>\0</TT> (backslash zero) into the replacement text. In Perl, the magic variable <TT>$&</TT> holds the entire regex match. Libraries like <A HREF="dotnet.html" TARGET="_top">.NET (dot net)</A> where backreferences are made available as an array or numbered list, the item with index zero holds the entire regex match. Using backreference zero is more efficient than putting an extra pair of round brackets around the entire regex, because that would force the engine to continuously keep an extra copy of the entire regex match.</P> <A NAME="usebackrefinregex"></A><H2>Using Backreferences in The Regular Expression</H2> <P>Backreferences can not only be used after a match has been found, but also during the match. Suppose you want to match a pair of opening and closing HTML tags, and the text in between. By putting the opening tag into a backreference, we can reuse the name of the tag for the closing tag. Here's how: <TT CLASS=regex>&lt;([A-Z][A-Z0-9]*)[^&gt;]*&gt;.*?&lt;/\1></TT> <A HREF="regexbuddy/bracketshtmlpair.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>. This regex contains only one pair of parentheses, which capture the string matched by <TT CLASS=regex>[A-Z][A-Z0-9]*</TT> into the first backreference. This backreference is reused with <TT CLASS=regex>\1</TT> (backslash one). The <TT CLASS=regex>/</TT> before it is simply the forward slash in the closing HTML tag that we are trying to match.</P> <P>You can reuse the same backreference more than once. <TT CLASS=regex>([a-c])x\1x\1</TT> will match <TT CLASS=match>axaxa</TT>, <TT CLASS=match>bxbxb</TT> and <TT CLASS=match>cxcxc</TT>. If a backreference was not used in a particular match attempt (such as in the first example where the question mark made the first backreference optional), it is simply empty. Using an empty backreference in the regex is perfectly fine. It will simply be replaced with nothingness.</P> <P>A backreference cannot be used inside itself. <TT CLASS=regex>([abc]\1)</TT> will not work. Depending on your regex flavor, it will either give an error message, or it will fail to match anything without an error message. Therefore, \0 cannot be used inside a regex, only in the replacement.</P> <H2>Looking Inside The Regex Engine</H2> <P>Let's see how the regex engine applies the above regex to the string <TT CLASS=string>Testing &lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt; text</TT>. The first token in the regex is the literal <TT CLASS=regex>&lt;</TT>. The regex engine will traverse the string until it can match at the first <TT CLASS=match>&lt;</TT> in the string. The next token is <TT CLASS=regex>[A-Z]</TT>. The regex engine also takes note that it is now inside the first pair of capturing parentheses. <TT CLASS=regex>[A-Z]</TT> matches <TT CLASS=match>B</TT>. The engine advances to <TT CLASS=regex>[A-Z0-9]</TT> and <TT CLASS=string>&gt;</TT>. This match fails. However, because of the <A HREF="repeat.html" TARGET="_top">star</A>, that's perfectly fine. The position in the string remains at <TT CLASS=string>&gt;</TT>. The position in the regex is advanced to <TT CLASS=regex>[^&gt;]</TT>.</P> <P>This step crosses the closing bracket of the first pair of capturing parentheses. This prompts the regex engine to store what was matched inside them into the first backreference. In this case, <TT CLASS=match>B</TT> is stored.</P> <P>After storing the backreference, the engine proceeds with the match attempt. <TT CLASS=regex>[^&gt;]</TT> does not match <TT CLASS=match>&gt;</TT>. Again, because of another star, this is not a problem. The position in the string remains at <TT CLASS=string>&gt;</TT>, and position in the regex is advanced to <TT CLASS=regex>&gt;</TT>. These obviously match. The next token is a dot, repeated by a lazy star. Because of the laziness, the regex engine will initially skip this token, taking note that it should backtrack in case the remainder of the regex fails.</P> <P>The engine has now arrived at the second <TT CLASS=regex>&lt;</TT> in the regex, and the second <TT CLASS=string>&lt;</TT> in the string. These match. The next token is <TT CLASS=regex>/</TT>. This does not match <TT CLASS=string>I</TT>, and the engine is forced to backtrack to the dot. The dot matches the second <TT CLASS=match>&lt;</TT> in the string. The star is still lazy, so the engine again takes note of the available backtracking position and advances to <TT CLASS=regex>&lt;</TT> and <TT CLASS=string>I</TT>. These do not match, so the engine again backtracks.</P> <P>The backtracking continues until the dot has consumed <TT CLASS=match>&lt;I&gt;bold italic</TT>. At this point, <TT CLASS=regex>&lt;</TT> matches the third <TT CLASS=match>&lt;</TT> in the string, and the next token is <TT CLASS=regex>/</TT> which matches <TT CLASS=string>/</TT>. The next token is <TT CLASS=regex>\1</TT>. Note that the token the backreference, and not <TT CLASS=regex>B</TT>. The engine does not substitute the backreference in the regular expression. Every time the engine arrives at the backreference, it will read the value that was stored. This means that if the engine had backtracked beyond the first pair of capturing parentheses before arriving the second time at <TT CLASS=regex>\1</TT>, the new value stored in the first backreference would be used. But this did not happen here, so <TT CLASS=match>B</TT> it is. This fails to match at <TT CLASS=string>I</TT>, so the engine backtracks again, and the dot consumes the third <TT CLASS=string>&lt;</TT> in the string.</P> <P>Backtracking continues again until the dot has consumed <TT CLASS=match>&lt;I&gt;bold italic&lt;/I&gt;</TT>. At this point, <TT CLASS=regex>&lt;</TT> matches <TT CLASS=match>&lt;</TT> and <TT CLASS=regex>/</TT> matches <TT CLASS=match>/</TT>. The engine arrives again at <TT CLASS=regex>\1</TT>. The backreference still holds <TT CLASS=match>B</TT>. <TT CLASS=regex>B</TT> matches <TT CLASS=match>B</TT>. The last token in the regex, <TT CLASS=regex>&gt;</TT> matches <TT CLASS=match>&gt;</TT>. A complete match has been found: <TT CLASS=match>&lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt;</TT>.</P> <A NAME="repeat"></A><H2>Repetition and Backreferences</H2> <P>As I mentioned in the above inside look, the regex engine does not permanently substitute backreferences in the regular expression. It will use the last match saved into the backreference each time it needs to be used. If a new match is found by capturing parentheses, the previously saved match is overwritten. There is a clear difference between <TT CLASS=regex>([abc]+)</TT> and <TT CLASS=regex>([abc])+</TT>. Though both successfully match <TT CLASS=match>cab</TT>, the first regex will put <TT CLASS=match>cab</TT> into the first backreference, while the second regex will only store <TT CLASS=match>b</TT>. That is because in the second regex, the plus caused the pair of parentheses to repeat three times. The first time, <TT CLASS=match>c</TT> was stored. The second time <TT CLASS=match>a</TT> and the third time <TT CLASS=match>b</TT>. Each time, the previous value was overwritten, so <TT CLASS=match>b</TT> remains.</P> <P>This also means that <TT CLASS=regex>([abc]+)=\1</TT> will match <TT CLASS=match>cab=cab</TT>, and that <TT CLASS=regex>([abc])+=\1</TT> will not. The reason is that when the engine arrives at <TT CLASS=regex>\1</TT>, it holds <TT CLASS=regex>b</TT> which fails to match <TT CLASS=string>c</TT>. Obvious when you look at a simple example like this one, but a common cause of difficulty with regular expressions nonetheless. When using backreferences, always double check that you are really capturing what you want.</P> <H2>Useful Example: Checking for Doubled Words</H2> <P>When editing text, doubled words such as "the the" easily creep in. Using the regex <TT CLASS=regex>\b(\w+)\s+\1\b</TT> <A HREF="regexbuddy/doubledword.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A> in your <A HREF="editpadpro.html" TARGET="_top">text editor</A>, you can easily find them. To delete the second word, simply type in <TT CLASS=string>\1</TT> as the replacement text and click the Replace button.</P> <H2>Parentheses and Backreferences Cannot Be Used Inside Character Classes</H2> <P>Round brackets cannot be used inside <A HREF="charclass.html" TARGET="_top">character classes</A>, at least not as metacharacters. When you put a round bracket in a character class, it is treated as a literal character. So the regex <TT CLASS=regex>[(a)b]</TT> matches <TT CLASS=match>a</TT>, <TT CLASS=match>b</TT>, <TT CLASS=match>(</TT> and <TT CLASS=match>)</TT>.</P> <P>Backreferences also cannot be used inside a character class. The \1 in regex like <TT CLASS=regex>(a)[\1b]</TT> will be interpreted as an octal escape in most regex flavors. So this regex will match an <tt class=match>a</tt> followed by either <TT CLASS=regex>\x01</TT> or a <TT CLASS=regex>b</TT>.</P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="brackets.html" TARGET="_top">http://www.Regular-Expressions.info/brackets.html</A><BR> Last Updated: 14 February 2005<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE><P>&nbsp;</P> <TABLE CLASS=side CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 3</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files, such as source code, correspondence, server or system logs, reference texts, archives, etc. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files, or thousands of files and folders.</TD></TR> <TR><TD CLASS=ad>Perform comprehensive text and binary replacement operations for easy maintenance of web sites, source code, reports, etc. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Work with plain text files, Unicode files, binary files, files stored in zip archives, and even MS Word documents, Excel spreadsheets and PDF files. Runs on Windows 98, ME, NT4, 2000 &amp; XP.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/brackets.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
</HTML>
<HTML>
<!-- Mirrored from www.regular-expressions.info/wordboundaries.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:48:33 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - \b Word Boundaries</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In regular expressions, \b anchors the regex at a word boundary or the position between a word and a non-word character, or vice versa.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Word Boundaries</H1> <P>The metacharacter <TT CLASS=regex>\b</TT> is an <A HREF="anchors.html" TARGET="_top">anchor</A> like the caret and the dollar sign. It matches at a position that is called a "word boundary". This match is zero-length.</P> <P>There are four different positions that qualify as word boundaries:</P> <UL> <LI>Before the first character in the string, if the first character is a word character. <LI>After the last character in the string, if the last character is a word character. <LI>Between a word character and a non-word character following right after the word character. <LI>Between a non-word character and a word character following right after the non-word character. </UL> <P>Simply put: <TT CLASS=regex>\b</TT> allows you to perform a "whole words only" search using a regular expression in the form of <TT CLASS=regex>\bword\b</TT>. A "word character" is a character that can be used to form words. All characters that are not "word characters" are "non-word characters". The exact list of characters is different for each regex flavor, but all word characters are always matched by the <A HREF="charclass.html#shorthand">short-hand character class</A> <TT CLASS=regex>\w</TT>. All non-word characters are always matched by <TT CLASS=regex>\W</TT>.</P> <P>In Perl and the other regex flavors discussed in this tutorial, there is only one metacharacter that matches both before a word and after a word. This is because any position between characters can never be both at the start and at the end of a word. Using only one operator makes things easier for you.</P> <P>Note that <TT CLASS=regex>\w</TT> usually also matches digits. So <TT CLASS=regex>\b4\b</TT> can be used to match a 4 that is not part of a larger number. This regex will not match <TT CLASS=string>44 sheets of a4</TT>. So saying "<TT CLASS=regex>\b</TT> matches before and after an alphanumeric sequence" is more exact than saying "before and after a word".</P> <A NAME="negated"></A><H2>Negated Word Boundary</H2> <P><TT CLASS=regex>\B</TT> is the negated version of <TT CLASS=regex>\b</TT>. <TT CLASS=regex>\B</TT> matches at every position where <TT CLASS=regex>\b</TT> does not. Effectively, <TT CLASS=regex>\B</TT> matches at any position between two word characters as well as at any position between two non-word characters.</P> <H2>Looking Inside the Regex Engine</H2> <P>Let's see what happens when we apply the regex <TT CLASS=regex>\bis\b</TT> to the string <TT CLASS=string>This island is beautiful</TT>. The engine starts with the first token <TT CLASS=regex>\b</TT> at the first character <TT CLASS=string>T</TT>. Since this token is zero-length, the position before the character is inspected. <TT CLASS=regex>\b</TT> matches here, because the T is a word character and the character before it is the void before the start of the string. The engine continues with the next token: the literal <TT CLASS=regex>i</TT>. The engine does not advance to the next character in the string, because the previous regex token was zero-width. <TT CLASS=regex>i</TT> does not match <TT CLASS=string>T</TT>, so the engine retries the first token at the next character position.</P> <P><TT CLASS=regex>\b</TT> cannot match at the position between the <TT CLASS=string>T</TT> and the <TT CLASS=string>h</TT>. It cannot match between the <TT CLASS=string>h</TT> and the <TT CLASS=string>i</TT> either, and neither between the <TT CLASS=string>i</TT> and the <TT CLASS=string>s</TT>.</P> <P>The next character in the string is a space. <TT CLASS=regex>\b</TT> matches here because the space is not a word character, and the preceding character is. Again, the engine continues with the <TT CLASS=regex>i</TT> which does not match with the space.</P> <P>Advancing a character and restarting with the first regex token, <TT CLASS=regex>\b</TT> matches between the space and the second <TT CLASS=string>i</TT> in the string. Continuing, the regex engine finds that <TT CLASS=regex>i</TT> matches <TT CLASS=match>i</TT> and <TT CLASS=regex>s</TT> matches <TT CLASS=match>s</TT>. Now, the engine tries to match the second <TT CLASS=regex>\b</TT> at the position before the <TT CLASS=string>l</TT>. This fails because this position is between two word characters. The engine reverts to the start of the regex and advances one character to the <TT CLASS=string>s</TT> in <TT CLASS=string>island</TT>. Again, the <TT CLASS=regex>\b</TT> fails to match and continues to do so until the second space is reached. It matches there, but matching the <TT CLASS=regex>i</TT> fails.</P> <P>But <TT CLASS=regex>\b</TT> matches at the position before the third <TT CLASS=string>i</TT> in the string. The engine continues, and finds that <TT CLASS=regex>i</TT> matches <TT CLASS=match>i</TT> and <TT CLASS=regex>s</TT> matches <TT CLASS=regex>s</TT>. The last token in the regex, <TT CLASS=regex>\b</TT>, also matches at the position before the second space in the string because the space is not a word character, and the character before it is.</P> <P>The engine has successfully matched the word <TT CLASS=match>is</TT> in our string, skipping the two earlier occurrences of the characters i and s. If we had used the regular expression <TT CLASS=regex>is</TT>, it would have matched the <TT CLASS=match>is</TT> in <TT CLASS=string>This</TT>.</P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="wordboundaries.html" TARGET="_top">http://www.Regular-Expressions.info/wordboundaries.html</A><BR> Last Updated: 17 May 2004<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/wordboundaries.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:48:33 GMT -->
</HTML>
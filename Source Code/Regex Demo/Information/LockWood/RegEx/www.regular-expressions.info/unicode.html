<HTML>
<!-- Mirrored from www.regular-expressions.info/unicode.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - Unicode Characters and Properties</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Unicode Regular Expressions</H1> <P>Unicode is a character set that aims to define all characters and glyphs from all human languages, living and dead. With more and more software being required to support multiple languages, or even just <I>any</I> language, Unicode has been strongly gaining popularity in recent years. Using different character sets for different languages is simply too cumbersome for programmers and users.</P> <P>Unfortunately, Unicode brings its own requirements and pitfalls when it comes to regular expressions. Of the regex flavors discussed in this tutorial, <A HREF="java.html" TARGET="_top">Java</A> and <A HREF="dotnet.html" TARGET="_top">the .NET framework</A> use Unicode-based regex engines. <A HREF="perl.html" TARGET="_top">Perl</A> supports Unicode starting with version 5.6.</P> <P><A HREF="regexbuddy.html" TARGET="_top">RegexBuddy's regex engine</A> is fully Unicode-based starting with version 2.0.0. RegexBuddy 1.x.x did not support Unicode at all. <A HREF="powergrep.html" TARGET="_top">PowerGREP</A> uses the same Unicode regex engine starting with version 3.0.0. Earlier versions would convert Unicode files to ANSI prior to grepping with an 8-bit (i.e. non-Unicode) regex engine.</P> <H2>Characters, Code Points and Graphemes or How Unicode Makes a Mess of Things</H2> <P>Most people would consider <TT class=string>&#x00E0;</TT> a single character. Unfortunately, it need not be depending on the meaning of the word "character".</P> <P>All regex engines discussed in this tutorial treat any single Unicode <I>code point</I> as a single character. When this tutorial tells you that <A HREF="dot.html" TARGET="_top">the dot matches any single character</A>, this translates into Unicode parlance as "the dot matches any single Unicode code point". In Unicode, <TT class=string>&#x00E0;</TT> can be encoded as two code points: U+0061 (a) followed by U+0300 (grave accent). In this situation, <TT CLASS=regex>.</TT> applied to <TT class=string>&#x00E0;</TT> will match <TT CLASS=match>a</TT> without the accent. <TT CLASS=regex>^.$</TT> will fail to match, since the string consists of two code points. <TT CLASS=regex>^..$</TT> matches <TT class=match>&#x00E0;</TT>.</P> <P>The Unicode code point U+0300 (grave accent) is a <I>combining mark</I>. Any code point that is not a combining mark can be followed by any number of combining marks. This sequence, like U+0061 U+0300 above, is displayed as a single <I>grapheme</I> on the screen. <P>Unfortunately, <TT class=string>&#x00E0;</TT> can also be encoded with the single Unicode code point U+00E0 (a with grave accent). The reason for this duality is that many historical character sets encode "a with grave accent" as a single character. Unicode's designers thought it would be useful to have a one-on-one mapping with popular legacy character sets, in addition to the Unicode way of separating marks and base letters (which makes arbitrary combinations not supported by legacy character sets possible).</P> <H2><A NAME="grapheme">How to Match a Single Unicode Grapheme</A></H2> <P>Matching a single grapheme, whether it's encoded as a single code point, or as multiple code points using combining marks, is easy in Perl, RegexBuddy and PowerGREP: simply use <TT CLASS=regex>\X</TT>. You can consider <TT CLASS=regex>\X</TT> the Unicode version of <A HREF="dot.html" TARGET="_top">the dot</A> in regex engines that use plain ASCII. There is one difference, though: <TT CLASS=regex>\X</TT> always matches line break characters, whereas the dot does not match line break characters unless you enable the <A HREF="modifiers.html" TARGET="_top">dot matches newline matching mode</A>.</P> <P>Java and .NET unfortunately do not support <TT CLASS=regex>\X</TT> (yet). Use <TT CLASS=regex>\P{M}\p{M}*</TT> as a substitute. To match any number of graphemes, use <TT CLASS=regex>(?:\P{M}\p{M}*)+</TT> instead of <TT CLASS=regex>\X+</TT>.</P> <H2><A NAME="prop">Unicode Character Properties</A></H2> <P>In addition to complications, Unicode also brings new possibilities. One is that each Unicode character belongs to a certain category. You can match a single character belonging to a particular category with <TT CLASS=regex>\p{}</TT>. You can match a single character <I>not</I> belonging to a particular category with <TT CLASS=regex>\P{}</TT>.</P> <P>Again, "character" really means "Unicode code point". <TT CLASS=regex>\p{L}</TT> matches a single code point in the category "letter". If your input string is <TT class=string>&#x00E0;</TT> encoded as U+0061 U+0300, it matches <TT class=match>a</TT> without the accent. If the input is <TT class=string>&#x00E0;</TT> encoded as U+00E0</TT>, it matches <TT class=match>&#x00E0;</TT> with the accent. The reason is that both the code points U+0061 (a) and U+00E0 (&#x00E0;) are in the category "letter", while U+0300 is in the category "mark".</P> <P>You should now understand why <TT CLASS=regex>\P{M}\p{M}*</TT> is the equivalent of <TT CLASS=regex>\X</TT>. <TT CLASS=regex>\P{M}</TT> matches a code point that is not a combining mark, while <TT CLASS=regex>\p{M}*</TT> matches <A HREF="repeat.html" TARGET="_top">zero or more</A> code points that are combining marks. To match a letter including any diacritics, use <TT CLASS=regex>\p{L}\p{M}*</TT>. This last regex will always match <TT class=match>&#x00E0;</TT>, regardless of how it is encoded.</P> <P>In addition to the standard notation, <TT CLASS=regex>\p{L}</TT>, Java, Perl, RegexBuddy and PowerGREP allow you to use the shorthand <TT CLASS=regex>\pL</TT>. In addition to that, Perl, RegexBuddy and PowerGREP also support the longhand <TT CLASS=regex>\p{Letter}</TT>.</P> <UL> <LI><TT CLASS=regex>\p{L}</TT> or <TT CLASS=regex>\p{Letter}</TT>: any kind of letter from any language. <UL> <LI><TT CLASS=regex>\p{Ll}</TT> or <TT CLASS=regex>\p{Lowercase_Letter}</TT>: a lowercase letter that has an uppercase variant. <LI><TT CLASS=regex>\p{Lu}</TT> or <TT CLASS=regex>\p{Uppercase_Letter}</TT>: an uppercase letter that has a lowercase variant. <LI><TT CLASS=regex>\p{Lt}</TT> or <TT CLASS=regex>\p{Titlecase_Letter}</TT>: a letter that appears at the start of a word when only the first letter of the word is capitalized. <LI><TT CLASS=regex>\p{L&}</TT> or <TT CLASS=regex>\p{Letter&}</TT>: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt). <LI><TT CLASS=regex>\p{Lm}</TT> or <TT CLASS=regex>\p{Modifier_Letter}</TT>: a special character that is used like a letter. <LI><TT CLASS=regex>\p{Lo}</TT> or <TT CLASS=regex>\p{Other_Letter}</TT>: a letter or ideograph that does not have lowercase and uppercase variants. </UL> <LI><TT CLASS=regex>\p{M}</TT> or <TT CLASS=regex>\p{Mark}</TT>: a character intended to be combined with another character (e.g. accents, umlauts, enclosing boxes, etc.). <UL> <LI><TT CLASS=regex>\p{Mn}</TT> or <TT CLASS=regex>\p{Non_Spacing_Mark}</TT>: a character intended to be combined with another character that does not take up extra space (e.g. accents, umlauts, etc.). <LI><TT CLASS=regex>\p{Mc}</TT> or <TT CLASS=regex>\p{Spacing_Combining_Mark}</TT>: a character intended to be combined with another character that takes up extra space (vowel signs in many Eastern languages). <LI><TT CLASS=regex>\p{Me}</TT> or <TT CLASS=regex>\p{Enclosing_Mark}</TT>: a character that encloses the character is is combined with (circle, square, keycap, etc.). </UL> <LI><TT CLASS=regex>\p{Z}</TT> or <TT CLASS=regex>\p{Separator}</TT>: any kind of whitespace or invisible separator. <UL> <LI><TT CLASS=regex>\p{Zs}</TT> or <TT CLASS=regex>\p{Space_Separator}</TT>: a whitespace character that is invisible, but does take up space. <LI><TT CLASS=regex>\p{Zl}</TT> or <TT CLASS=regex>\p{Line_Separator}</TT>: line separator character U+2028. <LI><TT CLASS=regex>\p{Zp}</TT> or <TT CLASS=regex>\p{Paragraph_Separator}</TT>: paragraph separator character U+2029. </UL> <LI><TT CLASS=regex>\p{S}</TT> or <TT CLASS=regex>\p{Symbol}</TT>: math symbols, currency signs, dingbats, box-drawing characters, etc.. <UL> <LI><TT CLASS=regex>\p{Sm}</TT> or <TT CLASS=regex>\p{Math_Symbol}</TT>: any mathematical symbol. <LI><TT CLASS=regex>\p{Sc}</TT> or <TT CLASS=regex>\p{Currency_Symbol}</TT>: any currency sign. <LI><TT CLASS=regex>\p{Sk}</TT> or <TT CLASS=regex>\p{Modifier_Symbol}</TT>: a combining character (mark) as a full character on its own. <LI><TT CLASS=regex>\p{So}</TT> or <TT CLASS=regex>\p{Other_Symbol}</TT>: various symbols that are not math symbols, currency signs, or combining characters. </UL> <LI><TT CLASS=regex>\p{N}</TT> or <TT CLASS=regex>\p{Number}</TT>: any kind of numeric character in any script. <UL> <LI><TT CLASS=regex>\p{Nd}</TT> or <TT CLASS=regex>\p{Decimal_Digit_Number}</TT>: a digit zero through nine in any script except ideographic scripts. <LI><TT CLASS=regex>\p{Nl}</TT> or <TT CLASS=regex>\p{Letter_Number}</TT>: a number that looks like a letter, such as a Roman numeral. <LI><TT CLASS=regex>\p{No}</TT> or <TT CLASS=regex>\p{Other_Number}</TT>: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). </UL> <LI><TT CLASS=regex>\p{P}</TT> or <TT CLASS=regex>\p{Punctuation}</TT>: any kind of punctuation character. <UL> <LI><TT CLASS=regex>\p{Pd}</TT> or <TT CLASS=regex>\p{Dash_Punctuation}</TT>: any kind of hyphen or dash. <LI><TT CLASS=regex>\p{Ps}</TT> or <TT CLASS=regex>\p{Open_Punctuation}</TT>: any kind of opening bracket. <LI><TT CLASS=regex>\p{Pe}</TT> or <TT CLASS=regex>\p{Close_Punctuation}</TT>: any kind of closing bracket. <LI><TT CLASS=regex>\p{Pi}</TT> or <TT CLASS=regex>\p{Initial_Punctuation}</TT>: any kind of opening quote. <LI><TT CLASS=regex>\p{Pf}</TT> or <TT CLASS=regex>\p{Final_Punctuation}</TT>: any kind of closing quote. <LI><TT CLASS=regex>\p{Pc}</TT> or <TT CLASS=regex>\p{Connector_Punctuation}</TT>: a punctuation character such as an underscore that connects words. <LI><TT CLASS=regex>\p{Po}</TT> or <TT CLASS=regex>\p{Other_Punctuation}</TT>: any kind of punctuation character that is not a dash, bracket, quote or connector. </UL> <LI><TT CLASS=regex>\p{C}</TT> or <TT CLASS=regex>\p{Other}</TT>: invisible control characters and unused code points. <UL> <LI><TT CLASS=regex>\p{Cc}</TT> or <TT CLASS=regex>\p{Control}</TT>: an ASCII 0x00..0x1F or Latin-1 0x80..0x9F control character. <LI><TT CLASS=regex>\p{Cf}</TT> or <TT CLASS=regex>\p{Format}</TT>: invisible formatting indicator. <LI><TT CLASS=regex>\p{Co}</TT> or <TT CLASS=regex>\p{Private_Use}</TT>: any code point reserved for private use. <LI><TT CLASS=regex>\p{Cs}</TT> or <TT CLASS=regex>\p{Surrogate}</TT>: one half of a surrogate pair in UTF-16 encoding. <LI><TT CLASS=regex>\p{Cn}</TT> or <TT CLASS=regex>\p{Unassigned}</TT>: any code point to which no character has been assigned. </UL> </UL> <H2>Do You Need To Worry About Different Encodings?</H2> <P>While you should always keep in mind the pitfalls created by the different ways in which accented characters can be encoded, you don't always have to worry about them. If you know that your input string and your regex use the same style, then you don't have to worry about it at all. This process is called Unicode <I>normalization</I>. All programming languages with native Unicode support, such as Java, C# and VB.NET, have library routines for normalizing strings. If you normalize both the subject and regex before attempting the match, there won't be any inconsistencies.</P> <P>If you are using Java, you can pass the CANON_EQ flag as the second parameter to Pattern.compile(). This tells the Java regex engine to consider <I>canonically equivalent</I> characters as identical. E.g. the regex <TT class=regex>&#x00E0;</TT> encoded as U+00E0 will match <TT class=match>&#x00E0;</TT> encoded as U+0061 U+0300, and vice versa. None of the other regex engines currently support canonical equivalence while matching.</P> <P>If you type the &#x00E0; key on the keyboard, all word processors that I know of will insert the code point U+00E0 into the file. So if you're working with text that you typed in yourself, any regex that you type in yourself will match in the same way.</P> <P>Finally, if you're using PowerGREP to search through text files encoded using a traditional Windows (often called "ANSI") or ISO-8859 code page, PowerGREP will always use the one-on-one substitution. Since all the Windows or ISO-8859 code pages encode accented characters as a single code point, all software that I know of will use a single Unicode code point for each character when converting the file to Unicode.</P> <H2>Matching a Specific Code Point</H2> <P>To match a specific Unicode code point, use <TT CLASS=regex>\uFFFF</TT> where FFFF is the hexadecimal number of the code point you want to match. E.g. <TT CLASS=regex>\u00E0</TT> matches <TT class=match>&#x00E0;</TT>, but only when encoded as a single code point U+00E0.</P> <P>In Java, the regex token <TT CLASS=regex>\uFFFF</TT> only matches the specified code point, even when you turned on canonical equivalence. However, the same syntax <TT>\uFFFF</TT> is also used to insert Unicode characters into literal strings in the Java source code. <TT>Pattern.compile("\u00E0")</TT> will match both the single-code-point and double-code-point encodings of <TT class=match>&#x00E0;</TT>, while <TT>Pattern.compile("\\u00E0")</TT> matches only the single-code-point version. Remember that when writing a regex as a Java string literal, backslashes must be escaped. The former Java code compiles the regex <TT class=regex>&#x00E0;</TT>, while the latter compiles <TT class=regex>\u00E0</TT>. Depending on what you're doing, the difference may be significant.</P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="unicode.html" TARGET="_top">http://www.Regular-Expressions.info/unicode.html</A><BR> Last Updated: 15 February 2005<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/unicode.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
</HTML>
<HTML>
<!-- Mirrored from www.regular-expressions.info/atomic.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - Atomic Grouping and Possessive Quantifiers</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Preventing catastrophic backtracking with atomic grouping and possessive quantifiers">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Atomic Grouping and Possessive Quantifiers</H1> <P>When discussing the <A HREF="repeat.html" TARGET="_top">repetition operators or quantifiers</A>, I explained the difference between greedy and lazy repetition. Greediness and laziness determine the order in which the regex engine tries the possible permutations of the regex pattern. A greedy quantifier will first try to repeat the token as many times as possible, and gradually give up matches as the engine backtracks to find an overall match. A lazy quantifier will first repeat the token as few times as required, and gradually expand the match as the engine backtracks through the regex to find an overall match.</P> <P>Because greediness and laziness change the order in which permutations are tried, they can change the overall regex match. However, they do not change the fact that the regex engine will backtrack to try all possible permutations of the regular expression in case no match can be found. First, let's see why backtracking can lead to problems.</P> <H2>Catastrophic Backtracking</H2> <P>Recently I got a complaint from a customer that <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> hung (i.e. it stopped responding) when trying to find lines in a comma-delimited text file where the 12th item on a line started with a <TT CLASS=string>P</TT>. The customer was using the regexp <TT CLASS=regex>^(.*?,){11}P</TT> <A HREF="regexbuddy/atomicproblem.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>.</P> <P>At first sight, this regex looks like it should do the job just fine. The lazy dot and comma match a single comma-delimited field, and the {11} skips the first 11 fields. Finally, the P checks if the 12th field indeed starts with P. In fact, this is exactly what will happen when the 12th field indeed starts with a P.</P> <P>The problem rears its ugly head when the 12th field does not start with a P. Let's say the string is <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13</TT>. At that point, the regex engine will backtrack. It will backtrack to the point where <TT CLASS=regex>^(.*?,){11}</TT> had consumed <TT CLASS=match>1,2,3,4,5,6,7,8,9,10,11</TT>, giving up the last match of the comma. The next token is again the dot. The dot matches a comma. <I>The dot matches the comma!</I> However, the comma does not match the <TT CLASS=string>1</TT> in the 12th field, so the dot continues until the 11th iteration of <TT CLASS=regex>.*?,</TT> has consumed <TT CLASS=match>11,12,</TT>. You can already see the root of the problem: the part of the regex (the dot) matching the contents of the field also matches the delimiter (the comma). Because of the double repetition (star inside {11}), this leads to a catastrophic amount of backtracking.</P> <P>The regex engine now checks whether the 13th field starts with a P. It does not. Since there is no comma after the 13th field, the regex engine can no longer match the 11th iteration of <TT CLASS=regex>.*?,</TT>. But it does not give up there. It backtracks to the 10th iteration, expanding the match of the 10th iteration to <TT CLASS=match>10,11,</TT>. Since there is still no P, the 10th iteration is expanded to <TT CLASS=match>10,11,12,</TT>. Reaching the end of the string again, the same story starts with the 9th iteration, subsequently expanding it to <TT CLASS=match>9,10,</TT>, <TT CLASS=match>9,10,11,</TT>, <TT CLASS=match>9,10,11,12,</TT>. But between each expansion, there are more possiblities to be tried. When the 9th iteration consumes <TT CLASS=match>9,10,</TT>, the 10th could match just <TT CLASS=match>11,</TT> as well as <TT CLASS=match>11,12,</TT>. Continuously failing, the engine backtracks to the 8th iteration, again trying all possible combinations for the 9th, 10th, and 11th iterations.</P> <P>You get the idea: the possible number of combinations that the regex engine will try for each line where the 12th field does not start with a P is huge. This causes software like EditPad Pro to stop responding longer than your patience lasts. Other applications may even crash as the regex engine runs out of memory trying to remember all backtracking positions.</P> <P>If you try this example with RegexBuddy's debugger, you will see that it needs 48,096 steps to conclude there regex cannot match. If the string is <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13,14</TT>, just 3 characters more, the number of steps jumps to 96,857. It's not too hard to imagine that at this kind of exponential rate, attempting this regex on a large file with long lines could easily take forever. RegexBuddy's debugger will abort the attempt after 100,000 steps, to prevent it from running out of memory.</P> <H2>Preventing Catastrophic Backtracking</H2> <P>The solution is simple. When nesting repetition operators, make absolutely sure that there is only one way to match the same match. If repeating the inner loop 4 times and the outer loop 7 times results in the same overall match as repeating the inner loop 6 times and the outer loop 2 times, you can be sure that the regex engine will try all those combinations.</P> <P>In our example, the solution is to be more exact about what we want to match. We want to match 11 comma-delimited fields. The fields must not contain comma's. So the regex becomes: <TT CLASS=regex>^([^,\r\n]*,){11}P</TT> <A HREF="regexbuddy/atomicsolution.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>. If the P cannot be found, the engine will still backtrack. But it will backtrack only 11 times, and each time the <TT CLASS=regex>[^,\r\n]</TT> is not able to expand beyond the comma, forcing the regex engine to the previous one of the 11 iterations immediately, without trying further options.</P> <A NAME="use"></A><H2>Atomic Grouping and Possessive Quantifiers</H2> <P>Recent regex flavors have introduced two additional solutions to this problem: atomic grouping and possessive quantifiers. Their purpose is to prevent backtracking, allowing the regex engine to fail faster.</P> <P>In the above example, we could easily reduce the amount of backtracking to a very low level by better specifying what we wanted. But that is not always possible in such a straightforward manner. In that case, you should use atomic grouping to prevent the regex engine from backtracking.</P> <P>Using atomic grouping, the above regex becomes <TT CLASS=regex>^<B>(?></B>(.*?,){11}<B>)</B>P</TT>. Everything between <TT>(?>)</TT> is treated as one single token by the regex engine, once the regex engine leaves the group. Because the entire group is one token, no backtracking can take place once the regex engine has found a match for the group. If backtracking is required, the engine has to backtrack to the regex token before the group (the caret in our example). If there is no token before the group, the regex must retry the entire regex at the next position in the string.</P> <P>Possessive quantifiers are a limited form of atomic grouping with a cleaner notation. To make a quantifier possessive, place a plus after it. <TT CLASS=regex>x++</TT> is the same as <TT CLASS=regex>(?>x+)</TT>. Similarly, you can use <TT CLASS=regex>x*+</TT>, <TT CLASS=regex>x?+</TT> and <TT CLASS=regex>x{m,n}+</TT>. Note that you cannot make a lazy quantifier possessive. It would match the minimum number of matches and never expand the match because backtracking is not allowed.</P> <H2>Tool and Language Support for Atomic Grouping and Possessive Quantifiers</H2> <P>Atomic grouping is a recent addition to the regex scene, and only supported by the latest versions of most regex flavors. <A HREF="perl.html" TARGET="_top">Perl</A> supports it starting with version 5.6. The <A HREF="java.html" TARGET="_top">Java</A> supports it starting with JDK version 1.4.2, though the JDK documentation uses the term "independent group" rather than "atomic group". All versions of <A HREF="dotnet.html" TARGET="_top">.NET</A> support atomic grouping, as do recent versions of <A HREF="pcre.html" TARGET="_top">PCRE</A>, <A HREF="php.html" TARGET="_top">PHP's pgreg functions</A> and <A HREF="ruby.html" TARGET="_top">Ruby</A>. <A HREF="python.html" TARGET="_top">Python</A> does not support atomic grouping.</P> <P>At this time, possessive quantifiers are only supported by the <A HREF="java.html" TARGET="_top">Java JDK 1.4.0</A> and later, and <A HREF="pcre.html" TARGET="_top">PCRE version 4 and later</A>.</P> <P>The latest versions of <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> and <A HREF="powergrep.html" TARGET="_top">PowerGREP</A> support both atomic grouping and possessive quantifiers, as do all versions of <A HREF="regexbuddy.html" TARGET="_top">RegexBuddy</A>.</P> <H2>Atomic Grouping Inside The Regex Engine</H2> <P>Let's see how <TT CLASS=regex>^(?>(.*?,){11})P</TT> is applied to <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13</TT>. The caret matches at the start of the string and the engine enters the atomic group. The star is lazy, so the dot is initially skipped. But the comma does not match <TT CLASS=string>1</TT>, so the engine backtracks to the dot. That's right: backtracking is allowed here. The star is not possessive, and is not immediately enclosed by an atomic group. That is, the regex engine did not cross the closing round bracket of the atomic group. The dot matches <TT CLASS=match>1</TT>, and the comma matches too. <TT CLASS=regex>{11}</TT> causes further repetition until the atomic group has matched <TT CLASS=match>1,2,3,4,5,6,7,8,9,10,11,</TT>.</P> <P>Now, the engine leaves the atomic group. Because the group is atomic, all backtracking information is discarded and the group is now considered a single token. The engine now tries to match <TT CLASS=regex>P</TT> to the <TT CLASS=string>1</TT> in the 12th field. This fails.</P> <P>So far, everything happened just like in the original, troublesome regular expression. Now comes the difference. <TT CLASS=regex>P</TT> failed to match, so the engine backtracks. The previous token is an atomic group, so the group's entire match is discarded and the engine backtracks further to the caret. The engine now tries to match the caret at the next position in the string, which fails. The engine walks through the string until the end, and declares failure. Failure is declared after 30 attempts to match the caret, and just one attempt to match the atomic group, rather than after 30 attempts to match the caret and a huge number of attempts to try all combinations of both quantifiers in the regex.</P> <P>That is what atomic grouping and possessive quantifiers are for: efficiency by disallowing backtracking. The most efficient regex for our problem at hand would be <TT CLASS=regex>^(?>((?>[^,\r\n]*),){11})P</TT> <A HREF="regexbuddy/atomic.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>, since possessive, greedy repetition of the star is faster than a backtracking lazy dot. If possessive quantifiers are available, you can reduce clutter by writing <TT CLASS=regex>^(?>([^,\r\n]*+,){11})P</TT> <A HREF="regexbuddy/atomicpossessive.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>.</P> <H2>When To Use Atomic Grouping or Possessive Quantifiers</H2> <P>Atomic grouping and possessive quantifiers speed up failure by eliminating backtracking. They do not speed up success, only failure. When nesting quantifiers like in the above example, you really should use atomic grouping and/or possessive quantifiers whenever possible. While <TT CLASS=regex>x[^x]*+x</TT> and <TT CLASS=regex>x(?>[^x]*)x</TT> fail faster than <TT CLASS=regex>x[^x]*x</TT>, the increase in speed is minimal. If the final x in the regex cannot be matched, the regex engine backtracks once for each character matched by the star. With simple repetition, the amount of time wasted with pointless backtracking increases in a linear fashion to the length of the string. With combined repetition, the amount of time wasted increases exponentially and will very quickly exhaust the capabilities of your computer. Still, if you are smart about combined repetition, you often can avoid the problem without atomic grouping as in the example above.</P> <P>If you are simply doing a search in a text editor, using simple repetition, you will not earn back the extra time to type in the characters for the atomic grouping. If the regex will be used in a tight loop in an application, or process huge amounts of data, then atomic grouping may make a difference.</P> <P>Note that atomic grouping and possessive quantifiers can alter the outcome of the regular expression match. <TT CLASS=regex>\d+6</TT> will match <TT CLASS=match>123456</TT> in <TT CLASS=string>123456789</TT>. <TT CLASS=regex>\d++6</TT> will not match at all. <TT CLASS=regex>\d+</TT> will match the entire string. With the former regex, the engine backtracks until the 6 can be matched. In the latter case, no backtracking is allowed, and the match fails. Again, the cause of this is that the token <TT CLASS=regex>\d</TT> that is repeated can also match the delimiter <TT CLASS=regex>6</TT>. Sometimes this is desirable, often it is not.</P> <P>This shows again that understanding how the regex engine works on the inside will enable you to avoid many pitfalls and craft efficient regular expressions that match exactly what you want.</P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="atomic.html" TARGET="_top">http://www.Regular-Expressions.info/atomic.html</A><BR> Last Updated: 14 July 2005<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE><P>&nbsp;</P> <TABLE CLASS=side CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 3</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files, such as source code, correspondence, server or system logs, reference texts, archives, etc. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files, or thousands of files and folders.</TD></TR> <TR><TD CLASS=ad>Perform comprehensive text and binary replacement operations for easy maintenance of web sites, source code, reports, etc. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Work with plain text files, Unicode files, binary files, files stored in zip archives, and even MS Word documents, Excel spreadsheets and PDF files. Runs on Windows 98, ME, NT4, 2000 &amp; XP.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/atomic.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
</HTML>
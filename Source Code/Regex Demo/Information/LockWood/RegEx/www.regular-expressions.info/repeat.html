<HTML>
<!-- Mirrored from www.regular-expressions.info/repeat.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:48:50 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - Repetition with Star and Plus</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In a regular expression, the asterisk or star causes the preceding token to be matched zero or more times, and the plus one or more times.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Repetition with Star and Plus</H1> <P>I already introduced one repetition operator or quantifier: the <A HREF="optional.html" TARGET="_top">question mark</A>. It tells the engine to attempt match the preceding token zero times or once, in effect making it optional.</P> <P>The asterisk or star tells the engine to attempt to match the preceding token zero or more times. The plus tells the engine to attempt to match the preceding token once or more. <TT CLASS=regex>&lt;[A-Za-z][A-Za-z0-9]*&gt;</TT> matches an HTML tag without any attributes. The sharp brackets are <A HREF="characters.html" TARGET="_top">literals</A>. The first <A HREF="charclass.html" TARGET="_top">character class</A> matches a letter. The second character class matches a letter or digit. The star repeats the second character class. Because we used the star, it's OK if the second character class matches nothing. So our regex will match a tag like <TT CLASS=match>&lt;B&gt;</TT>. When matching <TT CLASS=match>&lt;HTML&gt;</TT>, the first character class will match <TT CLASS=match>H</TT>. The star will cause the second character class to be repeated three times, matching <TT CLASS=match>T</TT>, <TT CLASS=match>M</TT> and <TT CLASS=match>L</TT> with each step.<P> <P>I could also have used <TT CLASS=regex>&lt;[A-Za-z0-9]+&gt;</TT>. I did not, because this regex would match <TT CLASS=match>&lt;1&gt;</TT>, which is not a valid HTML tag. But this regex may be sufficient if you know the string you are searching through does not contain any such invalid tags.</P> <A NAME="limit"></A><H2>Limiting Repetition</H2> <P>Modern regex flavors, like those discussed in this tutorial, have an additional repetition operator that allows you to specify how many times a token can be repeated. The syntax is <TT>{<I>min</I>,<I>max</I>}</TT>, where <I>min</I> is a positive integer number indicating the minimum number of matches, and <I>max</I> is an integer equal to or greater than <I>min</I> indicating the maximum number of matches. If the comma is present but <I>max</I> is omitted, the maximum number of matches is infinite. So <TT CLASS=regex>{0,}</TT> is the same as <TT CLASS=regex>*</TT>, and <TT CLASS=regex>{1,}</TT> is the same as <TT CLASS=regex>+</TT>. Omitting both the comma and <I>max</I> tells the engine to repeat the token exactly <I>min</I> times.</P> <P>You could use <TT CLASS=regex>\b[1-9][0-9]{3}\b</TT> to match a number between 1000 and 9999. <TT CLASS=regex>\b[1-9][0-9]{2,4}\b</TT> matches a number between 100 and 99999. Notice the use of the <A HREF="wordboundaries.html" TARGET="_top">word boundaries</A>.</P> <A NAME="greedy"></A><H2>Watch Out for The Greediness!</H2> <P>Suppose you want to use a regex to match an HTML tag. You know that the input will be a valid HTML file, so the regular expression does not need to exclude any invalid use of sharp brackets. If it sits between sharp brackets, it is an HTML tag.</P> <P>Most people new to regular expressions will attempt to use <TT CLASS=regex>&lt;.+&gt;</TT>. They will be surprised when they test it on a string like <TT CLASS=string>This is a &lt;EM&gt;first&lt;/EM&gt; test</TT>. You might expect the regex to match <TT CLASS=match>&lt;EM&gt;</TT> and when continuing after that match, <TT CLASS=match>&lt;/EM&gt;</TT>.</P> <P>But it does not. The regex will match <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt;</TT>. Obviously not what we wanted. The reason is that the plus is <I>greedy</I>. That is, the plus causes the regex engine to repeat the preceding token as often as possible. Only if that causes the entire regex to fail, will the regex engine <I>backtrack</I>. That is, it will go back to the plus, make it give up the last iteration, and proceed with the remainder of the regex. Let's take a look inside the regex engine to see in detail how this works and why this causes our regex to fail. After that, I will present you with two possible solutions.</P> <P>Like the plus, the star and the repetition using curly braces are greedy.</P> <H2>Looking Inside The Regex Engine</H2> <P>The first token in the regex is <TT CLASS=regex>&lt;</TT>. This is a <A HREF="characters.html" TARGET="_top">literal</A>. As we already know, the first place where it will match is the first <TT CLASS=match>&lt;</TT> in the string. The next token is the dot, which matches any character except newlines. The dot is repeated by the plus. The plus is <I>greedy</I>. Therefore, the engine will repeat the dot as many times as it can. The dot matches <TT CLASS=match>E</TT>, so the regex continues to try to match the dot with the next character. <TT CLASS=match>M</TT> is matched, and the dot is repeated once more. The next character is the <TT CLASS=string>&gt;</TT>. You should see the problem by now. The dot matches the <TT CLASS=match>&gt;</TT>, and the engine continues repeating the dot. The dot will match all remaining characters in the string. The dot fails when the engine has reached the void after the end of the string. Only at this point does the regex engine continue with the next token: <TT CLASS=regex>&gt;</TT>. <P>So far, <TT CLASS=regex>&lt;.+</TT> has matched <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt; test</TT> and the engine has arrived at the end of the string. <TT CLASS=regex>&gt;</TT> cannot match here. The engine remembers that the plus has repeated the dot more often than is required. (Remember that the plus <I>requires</I> the dot to match only once.) Rather than admitting failure, the engine will <I>backtrack</I>. It will reduce the repetition of the plus by one, and then continue trying the remainder of the regex.</P> <P>So the match of <TT CLASS=regex>.+</TT> is reduced to <TT CLASS=match>EM&gt;first&lt;/EM&gt; tes</TT>. The next token in the regex is still <TT CLASS=regex>&gt;</TT>. But now the next character in the string is the last <TT CLASS=string>t</TT>. Again, these cannot match, causing the engine to backtrack further. The total match so far is reduced to <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt; te</TT>. But <TT CLASS=regex>&gt;</TT> still cannot match. So the engine continues backtracking until the match of <TT CLASS=regex>.+</TT> is reduced to <TT CLASS=match>EM&gt;first&lt;/EM</TT>. Now, <TT CLASS=regex>&gt;</TT> can match the next character in the string. The last token in the regex has been matched. The engine reports that <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt;</TT> has been successfully matched.</P> <P>Remember that the regex engine is <I>eager</I> to return a match. It will not continue backtracking further to see if there is another possible match. It will report the first valid match it finds. Because of greediness, this is the leftmost longest match.</P> <A NAME="lazy"></A><H2>Laziness Instead of Greediness</H2> <P>The quick fix to this problem is to make the plus lazy instead of greedy. You can do that by putting a question mark behind the plus in the regex. You can do the same with the star, the curly braces and the question mark itself. So our example becomes <TT CLASS=regex>&lt;.+?&gt;</TT>. Let's have another look inside the regex engine.</P> <P>Again, <TT CLASS=regex>&lt;</TT> matches the first <TT CLASS=match>&lt;</TT> in the string. The next token is the dot, this time repeated by a lazy plus. This tells the regex engine to repeat the dot as few times as possible. The minimum is one. So the engine matches the dot with <TT CLASS=match>E</TT>. The requirement has been met, and the engine continues with <TT CLASS=regex>&gt;</TT> and <TT CLASS=string>M</TT>. This fails. Again, the engine will <I>backtrack</I>. But this time, the backtracking will force the lazy plus to expand rather than reduce its reach. So the match of <TT CLASS=regex>.+</TT> is expanded to <TT CLASS=match>EM</TT>, and the engine tries again to continue with <TT CLASS=regex>&gt;</TT>. Now, <TT CLASS=match>&gt;</TT> is matched successfully. The last token in the regex has been matched. The engine reports that <TT CLASS=match>&lt;EM&gt;</TT> has been successfully matched. That's more like it.</P> <H2>An Alternative to Laziness</H2> <P>In this case, there is a better option than making the plus lazy. We can use a greedy plus and a <A HREF="charclass.html" TARGET="_top">negated character class</A>: <TT CLASS=regex>&lt;[^&gt;]+&gt;</TT>. The reason why this is better is because of the backtracking. When using the lazy plus, the engine has to backtrack for each character in the HTML tag that it is trying to match. When using the negated character class, no backtracking occurs at all when the string contains valid HTML code. Backtracking slows down the regex engine. You will not notice the difference when doing a single search in a text editor. But you will save plenty of CPU cycles when using such a regex is used repeatedly in a tight loop in a script that you are writing, or perhaps in a custom syntax coloring scheme for <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A>.</P> <P>Finally, remember that this tutorial only talks about <A HREF="engine.html" TARGET="_top">regex-directed engines</A>. Text-directed engines do not backtrack. They do not get the speed penalty, but they also do not support lazy repetition operators. </P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="repeat.html" TARGET="_top">http://www.Regular-Expressions.info/repeat.html</A><BR> Last Updated: 13 January 2005<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE><P>&nbsp;</P> <TABLE CLASS=side CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 3</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files, such as source code, correspondence, server or system logs, reference texts, archives, etc. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files, or thousands of files and folders.</TD></TR> <TR><TD CLASS=ad>Perform comprehensive text and binary replacement operations for easy maintenance of web sites, source code, reports, etc. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Work with plain text files, Unicode files, binary files, files stored in zip archives, and even MS Word documents, Excel spreadsheets and PDF files. Runs on Windows 98, ME, NT4, 2000 &amp; XP.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/repeat.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:48:50 GMT -->
</HTML>
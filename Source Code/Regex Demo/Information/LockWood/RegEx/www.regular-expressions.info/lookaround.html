<HTML>
<!-- Mirrored from www.regular-expressions.info/lookaround.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Regex Tutorial - Lookahead and Lookbehind Zero-Width Assertions</TITLE>

<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Perl 5 expanded the regular expression syntax with zero-width assertions that allow you to test for a match, or test for failure, without actually consuming any characters.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<DIV CLASS=top><DIV CLASS=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<DIV CLASS=btntop><A CLASS=btntop HREF="tutorial.html" TARGET="_top">&nbsp;Tutorial&nbsp;</A><A CLASS=btntop HREF="tools.html" TARGET="_top">&nbsp;Tools&nbsp;&amp;&nbsp;Languages&nbsp;</A><A CLASS=btntop HREF="examples.html" TARGET="_top">&nbsp;Examples&nbsp;</A><A CLASS=btntop HREF="books.html" TARGET="_top">&nbsp;Books&nbsp;&amp;&nbsp;Reference&nbsp;</A></DIV>
<DIV CLASS=bodytext>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/rxb48.gif" WIDTH=48 HEIGHT=48 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>. Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this web site, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>, and get a FREE printable PDF version of the regex tutorial on this web site.</TD> </TR></TABLE> <H1>Lookahead and Lookbehind Zero-Width Assertions</H1> <P>Perl 5 introduced two very powerful constructs: "lookahead" and "lookbehind". Collectively, these are called "lookaround". They are also called "zero-width assertions". They are zero-width just like the <A HREF="anchors.html" TARGET="_top">start and end of line</A>, and <A HREF="wordboundaries.html" TARGET="_top">start and end of word</A> anchors that I already explained. The difference is that lookarounds will actually match characters, but then give up the match and only return the result: match or no match. That is why they are called "assertions". They do not consume characters in the string, but only assert whether a match is possible or not.</P> <P>Lookarounds allow you to create regular expressions that are impossible to create without them, or that would get very longwinded without them. All regex flavors discussed on this web site support lookaround. The exception is <A HREF="javascript.html" TARGET="_top">JavaScript</A>, which supports lookahead but not lookbehind.</P> <A NAME="lookahead"></A><H2>Positive and Negative Lookahead</H2> <P>Negative lookahead is indispensable if you want to match something not followed by something else. When explaining <A HREF="charclass.html" TARGET="_top">character classes</A>, I already explained why you cannot use a negated character class to match a "q" not followed by a "u". Negative lookahead provides the solution: <TT CLASS=regex>q(?!u)</TT>. The negative lookahead construct is the pair of round brackets, with the opening bracket followed by a question mark and an exclamation point. Inside the lookahead, we have the trivial regex <TT CLASS=regex>u</TT>.</P> <P>Positive lookahead works just the same. <TT CLASS=regex>q(?=u)</TT> matches a q that is followed by a u, without making the u part of the match. The positive lookahead construct is a pair of round brackets, with the opening bracket followed by a question mark and an equals sign.</P> <P>You can use any regular expression inside the lookahead. (Note that this is not the case with lookbehind. I will explain why below.) Any valid regular expression can be used inside the lookahead. If it contains capturing parentheses, the backreferences will be saved. Note that the lookahead itself does not create a backreference. So it is not included in the count towards numbering the backreferences. If you want to store the match of the regex inside a backreference, you have to put capturing parentheses around the regex inside the lookahead, like this: <TT CLASS=regex>(?=(regex))</TT>. The other way around will not work, because the lookahead will already have discarded the regex match by the time the backreference is to be saved.</P> <H2>Regex Engine Internals</H2> <P>First, let's see how the engine applies <TT CLASS=regex>q(?!u)</TT> to the string <TT CLASS=string>Iraq</TT>. The first token in the regex is the <A HREF="characters.html" TARGET="_top">literal</A> <TT CLASS=regex>q</TT>. As we already know, this will cause the engine to traverse the string until the <TT CLASS=match>q</TT> in the string is matched. The position in the string is now the void behind the string. The next token is the lookahead. The engine takes note that it is inside a lookahead construct now, and begins matching the regex inside the lookahead. So the next token is <TT CLASS=regex>u</TT>. This does not match the void behind the string. The engine notes that the regex inside the lookahead failed. Because the lookahead is negative, this means that the lookahead has successfully matched at the current position. At this point, the entire regex has matched, and <TT CLASS=match>q</TT> is returned as the match.</P> <P>Let's try applying the same regex to <TT CLASS=string>quit</TT>. <TT CLASS=regex>q</TT> matches <TT CLASS=match>q</TT>. The next token is the <TT CLASS=regex>u</TT> inside the lookahead. The next character is the <TT CLASS=string>u</TT>. These match. The engine advances to the next character: <TT CLASS=string>i</TT>. However, it is done with the regex inside the lookahead. The engine notes success, and discards the regex match. This causes the engine to step back in the string to <TT CLASS=string>u</TT>.</P> <P>Because the lookahead is negative, the successful match inside it causes the lookahead to fail. Since there are no other permutations of this regex, the engine has to start again at the beginning. Since <TT CLASS=regex>q</TT> cannot match anywhere else, the engine reports failure.</P> <P>Let's take one more look inside, to make sure you understand the implications of the lookahead. Let's apply <TT CLASS=regex>q(?=u)i</TT> to <TT CLASS=string>quit</TT>. I have made the lookahead positive, and put a token after it. Again, <TT CLASS=regex>q</TT> matches <TT CLASS=match>q</TT> and <TT CLASS=regex>u</TT> matches <TT CLASS=match>u</TT>. Again, the match from the lookahead must be discarded, so the engine steps back from <TT CLASS=string>i</TT> in the string to <TT CLASS=string>u</TT>. To lookahead was successful, so the engine continues with <TT CLASS=regex>i</TT>. But <TT CLASS=regex>i</TT> cannot match <TT CLASS=string>u</TT>. So this match attempt fails. All remaining attempts will fail as well, because there are no more q's in the string.</P> <A NAME="lookbehind"></A><H2>Positive and Negative Lookbehind</H2> <P>Lookbehind has the same effect, but works backwards. It tells the regex engine to temporarily step backwards in the string, to check if the text inside the lookbehind can be matched there. <TT CLASS=regex>(?&lt;!a)b</TT> matches a "b" that is not preceded by an "a", using negative lookbehind. It will not match <TT CLASS=string>cab</TT>, but will match the <TT CLASS=match>b</TT> (and only the <TT CLASS=match>b</TT>) in <TT CLASS=string>bed</TT> or <TT CLASS=string>debt</TT>. <TT CLASS=regex>(?&lt;=a)b</TT> (positive lookbehind) matches the <TT CLASS=match>b</TT> (and only the <TT CLASS=match>b</TT>) in <TT CLASS=match>cab</TT>, but does not match <TT CLASS=string>bed</TT> or <TT CLASS=string>debt</TT>.</P> <P>The construct for positive lookbehind is <TT CLASS=regex>(?&lt;=text)</TT>: a pair of round brackets, with the opening bracket followed by a question mark, "less than" symbol and an equals sign. Negative lookbehind is written as <TT CLASS=regex>(?&lt;!text)</TT>, using an exclamation point instead of an equals sign.</P> <H2>More Regex Engine Internals</H2> <P>Let's apply <TT CLASS=regex>(?&lt;=a)b</TT> to <TT CLASS=string>thingamabob</TT>. The engine starts with the lookbehind and the first character in the string. In this case, the lookbehind tells the engine to step back one character, and see if an "a" can be matched there. The engine cannot step back one character because there are no characters before the <TT CLASS=string>t</TT>. So the lookbehind fails, and the engine starts again at the next character, the <TT CLASS=string>h</TT>. (Note that a negative lookbehind would have succeeded here.) Again, the engine temporarily steps back one character to check if an "a" can be found there. It finds a <TT CLASS=string>t</TT>, so the positive lookbehind fails again.</P> <P>The lookbehind continues to fail until the regex reaches the <TT CLASS=string>m</TT> in the string. The engine again steps back one character, and notices that the <TT CLASS=match>a</TT> can be matched there. The positive lookbehind matches. Because it is zero-width, the current position in the string remains at the <TT CLASS=string>m</TT>. The next token is <TT CLASS=regex>b</TT>, which cannot match here. The next character is the second <TT CLASS=string>a</TT> in the string. The engine steps back, and finds out that the <TT CLASS=string>m</TT> does not match <TT CLASS=regex>a</TT>.</P> <P>The next character is the first <TT CLASS=string>b</TT> in the string. The engine steps back and finds out that <TT CLASS=match>a</TT> satisfies the lookbehind. <TT CLASS=regex>b</TT> matches <TT CLASS=match>b</TT>, and the entire regex has been matched successfully. It matches one character: the first <TT CLASS=match>b</TT> in the string.</P> <A NAME="limitbehind"></A><H2>Important Notes About Lookbehind</H2> <P>The good news is that you can use lookbehind anywhere in the regex, not only at the start. If you want to find a word not ending with an "s", you could use <TT CLASS=regex>\b\w+(?&lt;!s)\b</TT>. This is definitely not the same as <TT CLASS=regex>\b\w+[^s]\b</TT>. When applied to <TT CLASS=string>John's</TT>, the former will match <TT CLASS=match>John</TT> and the latter <TT CLASS=match>John'</TT> (including the apostrophe). I will leave it up to you to figure out why. (Hint: <TT CLASS=regex>\b</TT> matches between the apostrophe and the <TT CLASS=string>s</TT>). The latter will also not match single-letter words like "a" or "I". The correct regex without using lookbehind is <TT CLASS=regex>\b\w*[^s\W]\b</TT> (star instead of plus, and \W in the character class). Personally, I find the lookbehind easier to understand. The last regex, which works correctly, has a double negation (the \W in the negated character class). Double negations tend to be confusing to humans. Not to regex engines, though.</P> <P>The bad news is that most regex flavors do not allow you to use just any regex inside a lookbehind, because they cannot apply a regular expression backwards. Therefore, the regular expression engine needs to be able to figure out how many steps to step back before checking the lookbehind.</P> <P>Therefore, many regex flavors, including those used by <A HREF="perl.html" TARGET="_top">Perl 5</A> and Python, only allow fixed-length strings. You can use any regex of which the length of the match can be predetermined. This means you can use <A HREF="characters.html" TARGET="_top">literal text</A> and <A HREF="charclass.html" TARGET="_top">character classes</A>. You cannot use <A HREF="repeat.html" TARGET="_top">repetition</A> or <A HREF="optional.html" TARGET="_top">optional items</A>. You can use <A HREF="alternation.html" TARGET="_top">alternation</A>, but only if all options in the alternation have the same length.</P> <P>Some regex flavors support the above, plus alternation with strings of different lengths. But each string in the alternation must still be of fixed length, so only literals and character classes can be used. This includes <A HREF="pcre.html" TARGET="_top">PCRE</A>, <A HREF="php.html" TARGET="_top">PHP</A> and <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A>. <P>More advanced flavors support the above, plus finite repetition. This means you can still not use the <A HREF="repeat.html" TARGET="_top">star</A> or <A HREF="repeat.html" TARGET="_top">plus</A>, but you can use the <A HREF="optional.html" TARGET="_top">question mark</A> and the <A HREF="repeat.html" TARGET="_top">curly braces</A> with the max parameter specified. These regex flavors recognize the fact that finite repetition can be rewritten as an alternation of strings with different, but fixed lengths. The only regex flavor that I know of that currently supports this is Sun's regex package in the <A HREF="java.html" TARGET="_top">JDK 1.4</A>.</P> <P>The only regex flavors that allow you to use a full regular expression inside lookbehind are those used by <A HREF="regexbuddy.html" TARGET="_top">RegexBuddy</A> (2.0.3 and later), <A HREF="powergrep.html" TARGET="_top">PowerGREP</A> (3.0.0 and later), and the <A HREF="dotnet.html" TARGET="_top">.NET framework</A> (all versions).</P> <P>Finally, <A HREF="javascript.html" TARGET="_top">JavaScript</A> and <A HREF="ruby.html" TARGET="_top">Ruby</A> do not support lookbehind at all.</P> <H2>Lookaround Is Atomic</H2> <P>The fact that lookaround is zero-width automatically makes it <a href="atomic.html#use">atomic</a>. As soon as the lookaround condition is satisfied, the regex engine forgets about everything inside the lookaround. It will not backtrack inside the lookaround to try different permutations.</P> <P>The only situation in which this makes any difference is when you use <A HREF="brackets.html" TARGET="_top">capturing groups</A> inside the lookaround. Since the regex engine does not backtrack into the lookaround, it will not try different permutations of the capturing groups.</P> <P>For this reason, the regex <tt class=regex>(?=(\d+))\w+\1</tt> will never match <tt class=string>123x12</tt>. First the lookaround captures <tt class=match>123</tt> into <tt class=regex>\1</tt>. <tt class=regex>\w+</tt> then matches the whole string and backtracks until it matches only <tt class=match>1</tt>. Finally, <tt class=regex>\w+</tt> fails since <tt class=regex>\1</tt> cannot be matched at any position. Now, the regex engine has nothing to backtrack to, and the overall regex fails. The backtracking steps created by <tt class=regex>\d+</tt> have been discarded. It never gets to the point where the lookahead captures only <tt class=string>12</tt>.</P> <P>Obviously, the regex engine does try further positions in the string. If we change the subject string, the regex <tt class=regex>(?=(\d+))\w+\1</tt> will match <tt class=match>56x56</tt> in <tt class=string>456x56</tt>.</P> <P>If you don't use capturing groups inside lookaround, then all this doesn't matter. Either the lookaround condition can be satisfied or it cannot be. In how many ways it can be satisfied is irrelevant.</P><DIV CLASS=copyright> <P CLASS=copyright>Page URL: <A HREF="lookaround.html" TARGET="_top">http://www.Regular-Expressions.info/lookaround.html</A><BR> Last Updated: 10 June 2005<BR> Copyright &copy; 2003-2005 Jan Goyvaerts. All rights reserved.</P> </DIV> </DIV> <DIV CLASS=side><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index-2.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Download&nbsp;and&nbsp;Print</A></TD></TR></TABLE><P>&nbsp;</P> <TABLE CLASS=side CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 3</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files, such as source code, correspondence, server or system logs, reference texts, archives, etc. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files, or thousands of files and folders.</TD></TR> <TR><TD CLASS=ad>Perform comprehensive text and binary replacement operations for easy maintenance of web sites, source code, reports, etc. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Work with plain text files, Unicode files, binary files, files stored in zip archives, and even MS Word documents, Excel spreadsheets and PDF files. Runs on Windows 98, ME, NT4, 2000 &amp; XP.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV></BODY>
<!-- Mirrored from www.regular-expressions.info/lookaround.html by HTTrack Website Copier/3.x [XR&CO'2002], Mon, 14 Nov 2005 11:49:52 GMT -->
</HTML>